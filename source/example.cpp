// This software is in the public domain. Where that dedication is not
// recognized, you are granted a perpetual, irrevocable license to copy,
// distribute, and modify this file as you see fit.
// https://github.com/ddiakopoulos/tinyply
// Version 2.3

// The purpose of this file is to demonstrate the tinyply API and provide several almost-complete
// functions that can be copied and pasted into your own application or library. Because tinyply
// treats the file format as structured data, it's up to you to copy or move the parsed data
// into your application-specific data structures (e.g. float3, vec3, etc). 

#include "tinyply.h"
using namespace tinyply;

#include "example-utils.hpp"

void write_ply_example(const std::string & filename)
{
    geometry cube = make_cube_geometry();

    std::filebuf fb_binary;
    fb_binary.open(filename + "-binary.ply", std::ios::out | std::ios::binary);
    std::ostream outstream_binary(&fb_binary);
    if (outstream_binary.fail()) throw std::runtime_error("failed to open " + filename);

    std::filebuf fb_ascii;
    fb_ascii.open(filename + "-ascii.ply", std::ios::out);
    std::ostream outstream_ascii(&fb_ascii);
    if (outstream_ascii.fail()) throw std::runtime_error("failed to open " + filename);

    PlyFile cube_file;

    cube_file.add_properties_to_element("vertex", { "x", "y", "z" }, 
        Type::FLOAT32, cube.vertices.size(), reinterpret_cast<uint8_t*>(cube.vertices.data()), Type::INVALID, 0);

    cube_file.add_properties_to_element("vertex", { "nx", "ny", "nz" },
        Type::FLOAT32, cube.normals.size(), reinterpret_cast<uint8_t*>(cube.normals.data()), Type::INVALID, 0);

    cube_file.add_properties_to_element("vertex", { "u", "v" },
        Type::FLOAT32, cube.texcoords.size() , reinterpret_cast<uint8_t*>(cube.texcoords.data()), Type::INVALID, 0);

    cube_file.add_properties_to_element("face", { "vertex_indices" },
        Type::UINT32, cube.triangles.size(), reinterpret_cast<uint8_t*>(cube.triangles.data()), Type::UINT8, 3);

    cube_file.get_comments().push_back("generated by tinyply 3.0");

    // Write an ASCII file
    cube_file.write(outstream_ascii, false);

    // Write a binary file
    cube_file.write(outstream_binary, true);
}

void read_ply_file(const std::string & filepath, const bool preload_into_memory = true)
{
    std::cout << "........................................................................\n";
    std::cout << "Now Reading: " << filepath << std::endl;

    std::unique_ptr<std::istream> file_stream;
    std::vector<uint8_t> byte_buffer;

    try
    {
        // For most files < 1gb, pre-loading the entire file upfront and wrapping it into a 
        // stream is a net win for parsing speed, about 40% faster. 
        if (preload_into_memory)
        {
            byte_buffer = read_file_binary(filepath);
            file_stream.reset(new memory_stream((char*)byte_buffer.data(), byte_buffer.size()));
        }
        else
        {
            file_stream.reset(new std::ifstream(filepath, std::ios::binary));
        }

        if (!file_stream || file_stream->fail()) throw std::runtime_error("file_stream failed to open " + filepath);

        file_stream->seekg(0, std::ios::end);
        const float size_mb = file_stream->tellg() * float(1e-6);
        file_stream->seekg(0, std::ios::beg);

        PlyFile file;
        file.parse_header(*file_stream);

        std::cout << "\t[ply_header] Type: " << (file.is_binary_file() ? "binary" : "ascii") << std::endl;
        for (const auto & c : file.get_comments()) std::cout << "\t[ply_header] Comment: " << c << std::endl;
        for (const auto & c : file.get_info()) std::cout << "\t[ply_header] Info: " << c << std::endl;

        for (const auto & e : file.get_elements())
        {
            std::cout << "\t[ply_header] element: " << e.name << " (" << e.size << ")" << std::endl;
            for (const auto & p : e.properties)
            {
                std::cout << "\t[ply_header] \tproperty: " << p.name << " (type=" << tinyply::PropertyTable[p.propertyType].str << ")";
                if (p.isList) std::cout << " (list_type=" << tinyply::PropertyTable[p.listType].str << ")";
                std::cout << std::endl;
            }
        }

        // Because most people have their own mesh types, tinyply treats parsed data as structured/typed byte buffers. 
        // See examples below on how to marry your own application-specific data structures with this one. 
        std::shared_ptr<PlyData> vertices, normals, colors, texcoords, faces, tristrip;

        // The header information can be used to programmatically extract properties on elements
        // known to exist in the header prior to reading the data. For brevity of this sample, properties 
        // like vertex position are hard-coded. Also check out the parser from tests.cpp, which shows
        // how to programmatically extract all properties from all elements, which can be helpful 
        // to ensure use of of tinyply's little-endian binary fast-path. 
        try { vertices = file.request_properties_from_element("vertex", { "x", "y", "z" }); }
        catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

        try { normals = file.request_properties_from_element("vertex", { "nx", "ny", "nz" }); }
        catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

        try { colors = file.request_properties_from_element("vertex", { "red", "green", "blue", "alpha" }); }
        catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

        try { colors = file.request_properties_from_element("vertex", { "r", "g", "b", "a" }); }
        catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

        try { texcoords = file.request_properties_from_element("vertex", { "u", "v" }); }
        catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

        // !!! Important Performance Optimization !!! 
        // Providing a list size hint (the last argument) is a 2x performance improvement. If you have 
        // arbitrary in-the-wild user-imported ply files, you should not provide this argument. 
        try { faces = file.request_properties_from_element("face", { "vertex_indices" }, 3); }
        catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

        // Tristrips must always be read with a 0 list size hint (unless you know exactly how many elements
        // are specifically in the file, which is unlikely); 
        try { tristrip = file.request_properties_from_element("tristrips", { "vertex_indices" }, 0); }
        catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

        manual_timer read_timer;

        read_timer.start();
        file.read(*file_stream);
        read_timer.stop();

        const float parsing_time = static_cast<float>(read_timer.get()) / 1000.f;
        std::cout << "\tparsing " << size_mb << "mb in " << parsing_time << " seconds [" << (size_mb / parsing_time) << " MBps]" << std::endl;

        if (vertices)   std::cout << "\tRead " << vertices->count  << " total vertices "<< std::endl;
        if (normals)    std::cout << "\tRead " << normals->count   << " total vertex normals " << std::endl;
        if (colors)     std::cout << "\tRead " << colors->count << " total vertex colors " << std::endl;
        if (texcoords)  std::cout << "\tRead " << texcoords->count << " total vertex texcoords " << std::endl;
        if (faces)      std::cout << "\tRead " << faces->count     << " total faces (triangles) " << std::endl;
        if (tristrip)   std::cout << "\tRead " << (tristrip->buffer.size_bytes() / tinyply::PropertyTable[tristrip->t].stride) << " total indices (tristrip) " << std::endl;

        // Example One: converting to your own application types
        {
            const size_t numVerticesBytes = vertices->buffer.size_bytes();
            std::vector<float3> verts(vertices->count);
            std::memcpy(verts.data(), vertices->buffer.get(), numVerticesBytes);
        }

        // Example Two: converting to your own application type
        {
            std::vector<float3> verts_floats;
            std::vector<double3> verts_doubles;
            if (vertices->t == tinyply::Type::FLOAT32) { /* as floats ... */ }
            if (vertices->t == tinyply::Type::FLOAT64) { /* as doubles ... */ }
        }
    }
    catch (const std::exception & e)
    {
        std::cerr << "Caught tinyply exception: " << e.what() << std::endl;
    }
}

void read_gaussian_splat_ply(const std::string & filepath)
{
    std::ifstream file_stream(filepath, std::ios::binary);
    if (!file_stream) throw std::runtime_error("file_stream failed to open " + filepath);

    file_stream.seekg(0, std::ios::end);
    const float size_mb = file_stream.tellg() * float(1e-6);
    file_stream.seekg(0, std::ios::beg);

    tinyply::PlyFile splat_ply;
    splat_ply.parse_header(file_stream);

    std::cout << "\t[ply_header] Type: " << (splat_ply.is_binary_file() ? "binary" : "ascii") << std::endl;
    for (const auto & c : splat_ply.get_comments()) std::cout << "\t[ply_header] Comment: " << c << std::endl;
    for (const auto & c : splat_ply.get_info()) std::cout << "\t[ply_header] Info: " << c << std::endl;

    for (const auto & e : splat_ply.get_elements())
    {
        std::cout << "\t[ply_header] element: " << e.name << " (" << e.size << ")" << std::endl;
        for (const auto& p : e.properties) 
        {
            std::cout << "\t[ply_header] \tproperty: " << p.name << " (type=" << tinyply::PropertyTable[p.propertyType].str << ")";
            if (p.isList) std::cout << " (list_type=" << tinyply::PropertyTable[p.listType].str << ")";
            std::cout << std::endl;
        }
    }

    std::shared_ptr<tinyply::PlyData> xyz, nrm, f_dc, f_rest, opacity, scales, quat_rot;

    try { xyz = splat_ply.request_properties_from_element("vertex", { "x", "y", "z" }); }
    catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

    try { nrm = splat_ply.request_properties_from_element("vertex", { "nx", "ny", "nz" }); }
    catch (const std::exception& e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

    try { opacity = splat_ply.request_properties_from_element("vertex", { "opacity" }); }
    catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

    try { scales = splat_ply.request_properties_from_element("vertex", { "scale_0", "scale_1", "scale_2" }); }
    catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

    try { quat_rot = splat_ply.request_properties_from_element("vertex", { "rot_0", "rot_1", "rot_2", "rot_3" }); }
    catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

    std::vector<std::string> sh_dc_names;
    std::vector<std::string> sh_rest_names;

    std::vector<PlyElement> elements = splat_ply.get_elements();
    auto vertex_element_iter = std::find_if(elements.begin(), elements.end(), [](const PlyElement& e) { return e.name == "vertex"; });

    if (vertex_element_iter == elements.end()) 
    {
        throw std::runtime_error("[error] no vertex element found in ply file");
    }

    for (const auto & prop : vertex_element_iter->properties) 
    {
        if (prop.name.substr(0, 5) == "f_dc_")  {sh_dc_names.push_back(prop.name); }
        else if (prop.name.substr(0, 7) == "f_rest_") { sh_rest_names.push_back(prop.name); }
    }

    // get spherical harmonic coefficients
    try { f_dc = splat_ply.request_properties_from_element("vertex", sh_dc_names); }
    catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

    try 
    {
        f_rest = splat_ply.request_properties_from_element("vertex", sh_rest_names);
    }
    catch (const std::exception & e) 
    {
        // not an error if there are no f_rest components
        f_rest.reset();
    }

    manual_timer read_timer;

    read_timer.start();
    splat_ply.read(file_stream);
    read_timer.stop();

    if (xyz)      std::cout << "\tRead " << xyz->count << " total xyz " << std::endl;
    if (nrm)      std::cout << "\tRead " << nrm->count << " total normals " << std::endl;
    if (opacity)  std::cout << "\tRead " << opacity->count << " total opacity " << std::endl;
    if (scales)   std::cout << "\tRead " << scales->count << " total scales " << std::endl;
    if (quat_rot) std::cout << "\tRead " << quat_rot->count << " total quaternion rotations" << std::endl;
    if (f_dc)     std::cout << "\tRead " << f_dc->count << " total sh f_dc " << std::endl;
    if (f_rest)   std::cout << "\tRead " << f_rest->count << " total sh f_rest " << std::endl;

    const float parsing_time = static_cast<float>(read_timer.get()) / 1000.f;
    std::cout << "\tparsing " << size_mb << "mb in " << parsing_time << " seconds [" << (size_mb / parsing_time) << " MBps]" << std::endl;

    // do something with your fancy gaussian splat
}

int main(int argc, char *argv[])
{
    // Circular write-read
    write_ply_example("example_cube");
    read_ply_file("example_cube-ascii.ply");
    read_ply_file("example_cube-binary.ply", true);

    return EXIT_SUCCESS;
}
